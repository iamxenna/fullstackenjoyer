// SPDX-License-Identifier: MIT

pragma solidity >=0.7.0 <0.9.0;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

contract test is ERC20("CustomToken", "CMT") {

    address private _owner;

    uint256 private _tokenPrice = 2 ether;

    mapping(string => address) loginMap;
    mapping(address => User) userMap;
    mapping(address => string) passwordMap;
    mapping(uint => Review[]) reviewMapping;

    enum Role {
        User,
        Vendor,
        Admin
    }

    struct User {
        string login;
        uint age;
        Role role;
    }

    struct Review {
        uint id;
        string login;
        string review;
        uint mark;
    }

    constructor(address _address1, address _address2, address _address3) {

        _owner = msg.sender;

        userMap[_address1] = User("ivan", 30, Role.User);
        loginMap["ivan"] = _address1;
        passwordMap[_address1] = "123";
        userMap[_address2] = User("asd", 21, Role.Vendor);
        loginMap["asd"] = _address2;
        passwordMap[_address2] = "123";
        userMap[_address3] = User("admin", 21, Role.Admin);
        loginMap["admin"] = _address3;
        passwordMap[_address3] = "admin";

        _mint(_owner, 1000 * 1 ether);
        _mint(_address1, 1000 * 1 ether);
        _mint(_address2, 1000 * 1 ether);
        _mint(_address3, 1000 * 1 ether);
    }

    function registration(string memory _login, string memory _password, uint _age) public {
        require(loginMap[_login] == address(0), "user already exist");
        loginMap[_login] = msg.sender;
        passwordMap[msg.sender] = _password;
        userMap[msg.sender] = User(_login, _age, Role.User);
    }

    function auth(string memory _login, string memory _password) public view returns (User memory) {
        require(keccak256(abi.encode(userMap[loginMap[_login]].login)) == keccak256(abi.encode(_login)), "unknown user");
        require(keccak256(abi.encode(passwordMap[msg.sender])) == keccak256(abi.encode(_password)), "invalid password");
        return userMap[loginMap[_login]];
    }

    function addAdmin(address _address) public accessLevel(Role.Admin) {
        require(userMap[_address].role != Role.Admin, "admin already exists");
        userMap[_address].role = Role.Admin;
    }

    function addComment(uint _shop_id, string memory _review, uint _mark) public {
        require(_mark <= 10, "rating cantbe more than 10");
        uint _id = reviewMapping[_shop_id].length + 1;
        reviewMapping[_shop_id].push(Review(_id, userMap[msg.sender].login, _review, _mark));
    }

    function getComments(uint _id) public view returns (Review[] memory) {
        return reviewMapping[_id];
    }

    function buyToken(uint256 _amount) external payable {
        uint256 ownerBalance = balanceOf(_owner);
        _approve(_owner, msg.sender, ownerBalance);
        payable(_owner).transfer(msg.value);
        transferFrom(_owner, msg.sender, _amount*10**18);
    }

    function getTokenPrice() public view returns (uint) {
        return _tokenPrice;
    }

    function getBalance() public view returns(uint) {
        return msg.sender.balance;
    }

    modifier accessLevel(Role _role) {
        require(userMap[msg.sender].role >= _role, "access denied");
        _;
    }
}
